<!DOCTYPE html>
<html>
	<head>
		
			<title>Protocol::HTTP2::Connection</title>
		
		<meta charset="UTF-8"/>
		<meta name="viewport" content="width=device-width, initial-scale=1"/>
		
		<link rel="icon" type="image/png" href="../../../../_static/icon.png"/>
		<link rel="stylesheet" href="../../../../_static/site.css" type="text/css" media="screen"/>
		
		<script src="../../../../_components/jquery/jquery.min.js"></script>
		<script src="../../../../_components/jquery-syntax/jquery.syntax.min.js"></script>
		<script src="../../../../_components/mermaid/mermaid.min.js"></script>
		
		<script src="../../../../_static/links.js"></script>
		
		<script type="text/javascript">
		//<![CDATA[
			jQuery(function($) {
				$.syntax();
			});
			
			let isDarkMode = window.matchMedia("(prefers-color-scheme: dark)").matches
			let config = {theme: 'light'};
			if (isDarkMode) config.theme = 'dark';
			else config.theme = 'forest';
			mermaid.initialize(config);
		//]]>
		</script>
	</head>

	<body>
		<header> › <a class="link" href="../../../../index.html">Project</a> › <a class="link" href="../../../index.html">Source</a></header>
		
		<main>
			
	<h1><code class="language-ruby">Protocol::HTTP2::Connection</code></h1>
	
		
	
	
	
	<section>
	<h2>Definitions</h2>
	
	<section id="Protocol::HTTP2::Connection#maximum_frame_size"><h3><code class="language-ruby">def maximum_frame_size</code></h3><p>The size of a frame payload is limited by the maximum size that a receiver advertises in the SETTINGS_MAX_FRAME_SIZE setting.</p>
<details>
						<summary><h4>Implementation</h4></summary>
						<pre><code class="language-ruby">def maximum_frame_size
	@remote_settings.maximum_frame_size
end</code></pre>
					</details></section><section id="Protocol::HTTP2::Connection#state"><h3><code class="language-ruby">attr_accessor :state</code></h3><p>Connection state (:new, :open, :closed).</p>
</section><section id="Protocol::HTTP2::Connection#local_settings"><h3><code class="language-ruby">attr_accessor :local_settings</code></h3><p>Current settings value for local and peer</p>
</section><section id="Protocol::HTTP2::Connection#local_window"><h3><code class="language-ruby">attr :local_window</code></h3><p>Our window for receiving data. When we receive data, it reduces this window.
If the window gets too small, we must send a window update.</p>
</section><section id="Protocol::HTTP2::Connection#remote_window"><h3><code class="language-ruby">attr :remote_window</code></h3><p>Our window for sending data. When we send data, it reduces this window.</p>
</section><section id="Protocol::HTTP2::Connection#remote_stream_id"><h3><code class="language-ruby">attr :remote_stream_id</code></h3><p>The highest stream_id that has been successfully accepted by this connection.</p>
</section><section id="Protocol::HTTP2::Connection#closed?"><h3><code class="language-ruby">def closed?</code></h3><p>Whether the connection is effectively or actually closed.</p>
<details>
						<summary><h4>Implementation</h4></summary>
						<pre><code class="language-ruby">def closed?
	@state == :closed || @framer.nil?
end</code></pre>
					</details></section><section id="Protocol::HTTP2::Connection#close"><h3><code class="language-ruby">def close(error = nil)</code></h3><p>Close the underlying framer and all streams.</p>
<details>
						<summary><h4>Implementation</h4></summary>
						<pre><code class="language-ruby">def close(error = nil)
	# The underlying socket may already be closed by this point.
	@streams.each_value{|stream| stream.close(error)}
	@streams.clear
	
	if @framer
		@framer.close
		@framer = nil
	end
end</code></pre>
					</details></section><section id="Protocol::HTTP2::Connection#next_stream_id"><h3><code class="language-ruby">def next_stream_id</code></h3><p>Streams are identified with an unsigned 31-bit integer.  Streams initiated by a client MUST use odd-numbered stream identifiers; those initiated by the server MUST use even-numbered stream identifiers.  A stream identifier of zero (0x0) is used for connection control messages; the stream identifier of zero cannot be used to establish a new stream.</p>
<details>
						<summary><h4>Implementation</h4></summary>
						<pre><code class="language-ruby">def next_stream_id
	id = @local_stream_id
	
	@local_stream_id += 2
	
	return id
end</code></pre>
					</details></section><section id="Protocol::HTTP2::Connection#ignore_frame?"><h3><code class="language-ruby">def ignore_frame?(frame)</code></h3><p>6.8. GOAWAY
There is an inherent race condition between an endpoint starting new streams and the remote sending a GOAWAY frame. To deal with this case, the GOAWAY contains the stream identifier of the last peer-initiated stream that was or might be processed on the sending endpoint in this connection. For instance, if the server sends a GOAWAY frame, the identified stream is the highest-numbered stream initiated by the client.
Once sent, the sender will ignore frames sent on streams initiated by the receiver if the stream has an identifier higher than the included last stream identifier. Receivers of a GOAWAY frame MUST NOT open additional streams on the connection, although a new connection can be established for new streams.</p>
<details>
						<summary><h4>Implementation</h4></summary>
						<pre><code class="language-ruby">def ignore_frame?(frame)
	if self.closed?
		# puts &quot;ignore_frame? #{frame.stream_id} -&gt; #{valid_remote_stream_id?(frame.stream_id)} &gt; #{@remote_stream_id}&quot;
		if valid_remote_stream_id?(frame.stream_id)
			return frame.stream_id &gt; @remote_stream_id
		end
	end
end</code></pre>
					</details></section><section id="Protocol::HTTP2::Connection#read_frame"><h3><code class="language-ruby">def read_frame</code></h3><p>Reads one frame from the network and processes. Processing the frame updates the state of the connection and related streams. If the frame triggers an error, e.g. a protocol error, the connection will typically emit a goaway frame and re-raise the exception. You should continue processing frames until the underlying connection is closed.</p>
<details>
						<summary><h4>Implementation</h4></summary>
						<pre><code class="language-ruby">def read_frame
	frame = @framer.read_frame(@local_settings.maximum_frame_size)
	# puts &quot;#{self.class} #{@state} read_frame: class=#{frame.class} stream_id=#{frame.stream_id} flags=#{frame.flags} length=#{frame.length} (remote_stream_id=#{@remote_stream_id})&quot;
	# puts &quot;Windows: local_window=#{@local_window.inspect}; remote_window=#{@remote_window.inspect}&quot;
	
	return if ignore_frame?(frame)
	
	yield frame if block_given?
	frame.apply(self)
	
	return frame
rescue GoawayError =&gt; error
	# Go directly to jail. Do not pass go, do not collect $200.
	raise
rescue ProtocolError =&gt; error
	send_goaway(error.code || PROTOCOL_ERROR, error.message)
	
	raise
rescue HPACK::Error =&gt; error
	send_goaway(COMPRESSION_ERROR, error.message)
	
	raise
end</code></pre>
					</details></section><section id="Protocol::HTTP2::Connection#close!"><h3><code class="language-ruby">def close!</code></h3><p>Transition the connection into the closed state.</p>
<details>
						<summary><h4>Implementation</h4></summary>
						<pre><code class="language-ruby">def close!
	@state = :closed
	
	return self
end</code></pre>
					</details></section><section id="Protocol::HTTP2::Connection#send_goaway"><h3><code class="language-ruby">def send_goaway(error_code = 0, message = &quot;&quot;)</code></h3><p>Tell the remote end that the connection is being shut down. If the <code>error_code</code> is 0, this is a graceful shutdown. The other end of the connection should not make any new streams, but existing streams may be completed.</p>
<details>
						<summary><h4>Implementation</h4></summary>
						<pre><code class="language-ruby">def send_goaway(error_code = 0, message = &quot;&quot;)
	frame = GoawayFrame.new
	frame.pack @remote_stream_id, error_code, message
	
	write_frame(frame)
ensure
	self.close!
end</code></pre>
					</details></section><section id="Protocol::HTTP2::Connection#process_settings"><h3><code class="language-ruby">def process_settings(frame)</code></h3><p>In addition to changing the flow-control window for streams that are not yet active, a SETTINGS frame can alter the initial flow-control window size for streams with active flow-control windows (that is, streams in the &quot;open&quot; or &quot;half-closed (remote)&quot; state).  When the value of SETTINGS_INITIAL_WINDOW_SIZE changes, a receiver MUST adjust the size of all stream flow-control windows that it maintains by the difference between the new value and the old value.</p>
<details>
						<summary><h4>Implementation</h4></summary>
						<pre><code class="language-ruby">def process_settings(frame)
	if frame.acknowledgement?
		# The remote end has confirmed the settings have been received:
		changes = @local_settings.acknowledge
		
		update_local_settings(changes)
		
		return true
	else
		# The remote end is updating the settings, we reply with acknowledgement:
		reply = frame.acknowledge
		
		write_frame(reply)
		
		changes = frame.unpack
		@remote_settings.update(changes)
		
		update_remote_settings(changes)
		
		return false
	end
end</code></pre>
					</details></section><section id="Protocol::HTTP2::Connection#accept_stream"><h3><code class="language-ruby">def accept_stream(stream_id, &amp;block)</code></h3><p>Accept an incoming stream from the other side of the connnection.
On the server side, we accept requests.</p>
<details>
						<summary><h4>Implementation</h4></summary>
						<pre><code class="language-ruby">def accept_stream(stream_id, &amp;block)
	unless valid_remote_stream_id?(stream_id)
		raise ProtocolError, &quot;Invalid stream id: #{stream_id}&quot;
	end
	
	create_stream(stream_id, &amp;block)
end</code></pre>
					</details></section><section id="Protocol::HTTP2::Connection#accept_push_promise_stream"><h3><code class="language-ruby">def accept_push_promise_stream(stream_id, &amp;block)</code></h3><p>Accept an incoming push promise from the other side of the connection.
On the client side, we accept push promise streams.
On the server side, existing streams create push promise streams.</p>
<details>
						<summary><h4>Implementation</h4></summary>
						<pre><code class="language-ruby">def accept_push_promise_stream(stream_id, &amp;block)
	accept_stream(stream_id, &amp;block)
end</code></pre>
					</details></section><section id="Protocol::HTTP2::Connection#create_stream"><h3><code class="language-ruby">def create_stream(id = next_stream_id, &amp;block)</code></h3><p>Create a stream, defaults to an outgoing stream.
On the client side, we create requests.</p>
<details>
						<summary><h4>Implementation</h4></summary>
						<pre><code class="language-ruby">def create_stream(id = next_stream_id, &amp;block)
	if block_given?
		return yield(self, id)
	else
		return Stream.create(self, id)
	end
end</code></pre>
					</details></section><section id="Protocol::HTTP2::Connection#receive_headers"><h3><code class="language-ruby">def receive_headers(frame)</code></h3><p>On the server side, starts a new request.</p>
<details>
						<summary><h4>Implementation</h4></summary>
						<pre><code class="language-ruby">def receive_headers(frame)
	stream_id = frame.stream_id
	
	if stream_id.zero?
		raise ProtocolError, &quot;Cannot receive headers for stream 0!&quot;
	end
	
	if stream = @streams[stream_id]
		stream.receive_headers(frame)
	else
		if stream_id &lt;= @remote_stream_id
			raise ProtocolError, &quot;Invalid stream id: #{stream_id} &lt;= #{@remote_stream_id}!&quot;
		end
		
		if @streams.size &lt; self.maximum_concurrent_streams
			stream = accept_stream(stream_id)
			@remote_stream_id = stream_id
			
			stream.receive_headers(frame)
		else
			raise ProtocolError, &quot;Exceeded maximum concurrent streams&quot;
		end
	end
end</code></pre>
					</details></section><section id="Protocol::HTTP2::Connection#receive_priority"><h3><code class="language-ruby">def receive_priority(frame)</code></h3><p>Sets the priority for an incoming stream.</p>
<details>
						<summary><h4>Implementation</h4></summary>
						<pre><code class="language-ruby">def receive_priority(frame)
	if dependency = @dependencies[frame.stream_id]
		dependency.receive_priority(frame)
	elsif idle_stream_id?(frame.stream_id)
		Dependency.create(self, frame.stream_id, frame.unpack)
	end
end</code></pre>
					</details></section><section id="Protocol::HTTP2::Connection#consume_window"><h3><code class="language-ruby">def consume_window(size = self.available_size)</code></h3><p>Traverse active streams in order of priority and allow them to consume the available flow-control window.</p>
<details>
						<summary><h4>Implementation</h4></summary>
						<pre><code class="language-ruby">def consume_window(size = self.available_size)
	# Return if there is no window to consume:
	return unless size &gt; 0
	
	# Console.logger.debug(self) do |buffer|
	# 	@dependencies.each do |id, dependency|
	# 		buffer.puts &quot;- #{dependency}&quot;
	# 	end
	# 
	# 	buffer.puts
	# 
	# 	@dependency.print_hierarchy(buffer)
	# end
	
	@dependency.consume_window(size)
end</code></pre>
					</details></section>	</section>
	
	

				
			<footer>Documentation generated by <a href="https://github.com/socketry/utopia-project">Utopia::Project</a>.</footer>
		</main>
	</body>
</html>

